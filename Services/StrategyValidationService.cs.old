using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using KiteMarketDataService.Worker.Data;
using KiteMarketDataService.Worker.Models;

namespace KiteMarketDataService.Worker.Services
{
    /// <summary>
    /// Validates predictions when D1 actual data arrives
    /// Calculates accuracy metrics and updates performance
    /// </summary>
    public class StrategyValidationService
    {
        private readonly IServiceScopeFactory _scopeFactory;
        private readonly ILogger<StrategyValidationService> _logger;
        private const string STRATEGY_NAME = "LC_UC_DISTANCE_MATCHER";
        private const decimal STRATEGY_VERSION = 1.0m;

        public StrategyValidationService(
            IServiceScopeFactory scopeFactory,
            ILogger<StrategyValidationService> logger)
        {
            _scopeFactory = scopeFactory;
            _logger = logger;
        }

        /// <summary>
        /// Validate all predictions for D0‚ÜíD1
        /// </summary>
        public async Task ValidatePredictionsAsync(DateTime predictionDate, DateTime actualDate, string indexName)
        {
            try
            {
                _logger.LogInformation($"üîç Validating predictions: {predictionDate:yyyy-MM-dd} ‚Üí {actualDate:yyyy-MM-dd} for {indexName}");

                using var scope = _scopeFactory.CreateScope();
                var context = scope.ServiceProvider.GetRequiredService<MarketDataContext>();

                // Get all predictions for this D0‚ÜíD1
                var predictions = await context.StrategyPredictions
                    .Where(p => p.PredictionDate == predictionDate
                        && p.TargetDate == actualDate
                        && p.IndexName == indexName
                        && p.StrategyName == STRATEGY_NAME)
                    .ToListAsync();

                if (!predictions.Any())
                {
                    _logger.LogWarning($"No predictions found for {predictionDate:yyyy-MM-dd} ‚Üí {actualDate:yyyy-MM-dd}");
                    return;
                }

                // Get D1 actual spot data
                var actualSpot = await context.HistoricalSpotData
                    .Where(s => s.TradingDate == actualDate && s.IndexName == indexName)
                    .FirstOrDefaultAsync();

                if (actualSpot == null)
                {
                    _logger.LogWarning($"No actual spot data found for {actualDate:yyyy-MM-dd}");
                    return;
                }

                var validations = new List<StrategyValidation>();

                // Validate each prediction
                foreach (var prediction in predictions)
                {
                    var validation = await ValidateSinglePrediction(prediction, actualSpot, context);
                    if (validation != null)
                    {
                        validations.Add(validation);
                    }
                }

                // Store validations
                await context.StrategyValidations.AddRangeAsync(validations);
                await context.SaveChangesAsync();

                // Update performance metrics
                await UpdatePerformanceMetrics(context, validations, predictionDate, indexName);

                _logger.LogInformation($"‚úÖ Validated {validations.Count} predictions");
                LogValidationSummary(validations);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Failed to validate predictions for {indexName}");
                throw;
            }
        }

        /// <summary>
        /// Validate a single prediction
        /// </summary>
        private async Task<StrategyValidation?> ValidateSinglePrediction(
            StrategyPrediction prediction,
            HistoricalSpotData actualSpot,
            MarketDataContext context)
        {
            decimal actualValue = 0;
            string patternObserved = "";

            // Get actual value based on prediction type
            switch (prediction.PredictionType)
            {
                case "SPOT_HIGH":
                case "SPOT_HIGH_ALT":
                    actualValue = actualSpot.HighPrice;
                    patternObserved = $"Spot high reached {actualValue:F2}";
                    break;

                case "SPOT_LOW":
                    actualValue = actualSpot.LowPrice;
                    patternObserved = $"Spot low reached {actualValue:F2}";
                    break;

                case "SPOT_CLOSE":
                    actualValue = actualSpot.ClosePrice;
                    patternObserved = $"Spot closed at {actualValue:F2}";
                    break;

                case "DAY_RANGE":
                    actualValue = actualSpot.HighPrice - actualSpot.LowPrice;
                    patternObserved = $"Day range was {actualValue:F2} points";
                    break;

                case "BOUNDARY_UPPER":
                    actualValue = actualSpot.HighPrice;
                    patternObserved = actualValue <= prediction.PredictedValue
                        ? "‚úÖ Boundary held - high stayed below limit"
                        : "‚ùå Boundary violated - high exceeded limit!";
                    break;

                case "BOUNDARY_LOWER":
                    actualValue = actualSpot.LowPrice;
                    patternObserved = actualValue >= prediction.PredictedValue
                        ? "‚úÖ Boundary held - low stayed above limit"
                        : "‚ùå Boundary violated - low fell below limit!";
                    break;

                case "SOFT_CEILING":
                    actualValue = actualSpot.HighPrice;
                    patternObserved = actualValue <= prediction.PredictedValue
                        ? $"‚úÖ Soft ceiling respected - high={actualValue:F2}, ceiling={prediction.PredictedValue:F2}"
                        : $"‚ö†Ô∏è Soft ceiling breached - high={actualValue:F2}, ceiling={prediction.PredictedValue:F2}";
                    break;

                case "PREMIUM_VALUE":
                    // For premium, we need to check if this value appeared anywhere
                    // This is more complex - for now, mark as partial validation
                    actualValue = prediction.PredictedValue; // Placeholder
                    patternObserved = "Premium value validation - requires option chain scan";
                    break;

                default:
                    return null;
            }

            // Calculate metrics
            decimal error = Math.Abs(prediction.PredictedValue - actualValue);
            decimal errorPct = actualValue != 0 ? (error / actualValue) * 100 : 0;
            decimal accuracyPct = Math.Max(0, 100 - errorPct);

            // Determine status
            string status = accuracyPct switch
            {
                >= 99.0m => "EXCELLENT",
                >= 95.0m => "SUCCESS",
                >= 90.0m => "PARTIAL",
                _ => "FAIL"
            };

            bool withinTolerance = error <= 100; // Within 100 points = success

            return new StrategyValidation
            {
                PredictionId = prediction.Id,
                ActualDate = actualSpot.TradingDate,
                ActualValue = actualValue,
                Error = error,
                ErrorPercentage = errorPct,
                AccuracyPercentage = accuracyPct,
                Status = status,
                WithinTolerance = withinTolerance,
                PatternObserved = patternObserved,
                ValidationNotes = $"Predicted: {prediction.PredictedValue:F2}, Actual: {actualValue:F2}, Error: {error:F2} pts ({errorPct:F2}%)"
            };
        }

        /// <summary>
        /// Update strategy performance metrics
        /// </summary>
        private async Task UpdatePerformanceMetrics(
            MarketDataContext context,
            List<StrategyValidation> validations,
            DateTime predictionDate,
            string indexName)
        {
            if (!validations.Any()) return;

            // Get or create performance record
            var performance = await context.StrategyPerformances
                .FirstOrDefaultAsync(p => p.StrategyName == STRATEGY_NAME 
                    && p.StrategyVersion == STRATEGY_VERSION);

            if (performance == null)
            {
                performance = new StrategyPerformance
                {
                    StrategyName = STRATEGY_NAME,
                    StrategyVersion = STRATEGY_VERSION,
                    StrategyStatus = "TESTING",
                    IsProduction = false
                };
                await context.StrategyPerformances.AddAsync(performance);
            }

            // Update metrics
            int successCount = validations.Count(v => v.AccuracyPercentage >= 95);
            int failCount = validations.Count(v => v.AccuracyPercentage < 95);

            performance.TotalPredictions += validations.Count;
            performance.SuccessfulPredictions += successCount;
            performance.FailedPredictions += failCount;

            var accuracies = validations.Select(v => v.AccuracyPercentage).ToList();
            performance.AverageAccuracy = accuracies.Average();
            performance.BestAccuracy = accuracies.Max();
            performance.WorstAccuracy = accuracies.Min();

            var errors = validations.Select(v => v.Error).ToList();
            performance.AverageError = errors.Average();
            performance.MedianError = errors.OrderBy(e => e).ElementAt(errors.Count / 2);

            performance.SuccessRate = performance.TotalPredictions > 0
                ? (decimal)performance.SuccessfulPredictions / performance.TotalPredictions * 100
                : 0;

            performance.FirstPredictionDate ??= predictionDate;
            performance.LastPredictionDate = predictionDate;
            performance.DaysTested = (predictionDate - (performance.FirstPredictionDate ?? predictionDate)).Days + 1;

            // Promote to production if consistently excellent
            if (performance.DaysTested >= 5 && performance.AverageAccuracy >= 99.0m)
            {
                performance.StrategyStatus = "ACTIVE";
                performance.IsProduction = true;
            }

            performance.LastUpdated = DateTime.UtcNow.AddHours(5.5);

            await context.SaveChangesAsync();

            _logger.LogInformation($"üìä Performance updated: {performance.AverageAccuracy:F2}% avg accuracy, {performance.SuccessRate:F2}% success rate");
        }

        /// <summary>
        /// Log validation summary
        /// </summary>
        private void LogValidationSummary(List<StrategyValidation> validations)
        {
            _logger.LogInformation("üìä Validation Summary:");
            foreach (var v in validations.OrderByDescending(x => x.AccuracyPercentage))
            {
                _logger.LogInformation($"  {v.Status,-10} {v.AccuracyPercentage,6:F2}% - {v.ValidationNotes}");
            }
        }
    }
}

